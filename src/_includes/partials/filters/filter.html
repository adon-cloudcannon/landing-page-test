<!-- custom checkbox styling -->
<style>
    .custom-checkbox {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 16px;
        height: 16px;
        border: 2px solid #034AD8;
        border-radius: 4px;
        position: relative;
        cursor: pointer;
    }
    
    input[type="checkbox"]:checked + .custom-checkbox {
        background-color: #034AD8;
        border-color: #034AD8;
    }
    
    input[type="checkbox"]:checked + .custom-checkbox::after {
        content: '\2713';
        position: absolute;
        color: white;
        font-size: 16px;
    }
</style>

<div x-data="filterComponent()" x-init="init()" class="mb-8 relative">
    <!-- Dropdowns -->
    <div class="flex flex-col md:flex-row gap-4">
        {% for filter in filter_type %}
            <div class="relative inline-block w-full md:w-auto">
                <!-- Button -->
                <button @click.prevent="toggleDropdown('{{ forloop.index }}')" class="z-10 border-2 border-stone-300/20 rounded-lg px-4 py-3 bg-white w-full md:w-[200px] flex justify-between items-center relative"
                :class="{
                    'bg-[#F0F5FF]': open && show === '{{ forloop.index }}',
                    'bg-white border-comet/50': !open && isMobile && filters['{{filter}}']?.length > 0,
                    'border-stone-300/20': !open && (!isMobile || filters['{{filter}}']?.length === 0)
                }"
                data-index="{{ forloop.index }}"
                aria-haspopup="true" 
                :aria-expanded="open && show === '{{ forloop.index }}'"
                aria-label="Show filters for {{ filter }}"
                >
                    <span class="inline-block" x-text="getButtonText('{{ filter }}', '{{ filter }}')"></span>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="stroke-current inline-block w-3 h-3 text-black transform transition duration-150" :class="{ 'rotate-90': show === '{{ forloop.index }}' }">
                        <path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 010 1.06l-7.5 7.5a.75.75 0 01-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 011.06-1.06l7.5 7.5z" clip-rule="evenodd"/>
                    </svg>
                    <span class="absolute top-0 right-0 w-2 h-2 bg-cc rounded-full" x-show="isMobile && filters['{{ filter }}']?.length > 0" style="transform: translate(50%, -50%);"></span>
                </button>
                
                <!-- Dropdown -->
    
        <div x-show.transition="show === '{{ forloop.index }}'" @click.away="if(show === '{{ forloop.index }}') show = false" role="menu" class="absolute top-full z-20 mt-2 w-full md:w-[200px] shadow-menu rounded-lg px-4 py-4 gap-y-4 whitespace-nowrap bg-white">
            {% assign filter_key = filter %}
            {% assign item_collection = collection %}
            {% assign filter_targets = "" | split: "," %}
        
            {% if filter_key == "framework" or filter_key == "category" or filter_key == "location" %}
                {% assign data_keys = "ssg_frameworks,categories,locations" | split: "," %}
                {% assign key_map = "framework,category,location" | split: "," %}
                {% assign key_index = -1 %}
                
                {% for key in key_map %}
                    {% if key == filter_key %}
                        {% assign key_index = forloop.index0 %}
                    {% endif %}
                {% endfor %}
                
                {% if key_index != -1 %}
                    {% assign target_key = data_keys[key_index] %}
                {% endif %}
        
                {% for item in item_collection %}
                    {% assign targets = item.data[target_key] %}
        
                    {% for target in targets %}
                        {% assign trimmed_target = target | strip %}
                        {% if trimmed_target != empty and trimmed_target != null and trimmed_target != "" %}
                            {% if filter_key == "location" %}
                                {% assign trimmed_target = trimmed_target | capitalize %}
                            {% endif %}
                            {% unless filter_targets contains trimmed_target %}
                                {% assign filter_targets = filter_targets | push: trimmed_target %}
                            {% endunless %}
                        {% endif %}
                    {% endfor %}
                {% endfor %}
            {% endif %}

            {% assign filter_targets = filter_targets | sort %}
        
            {% for target in filter_targets %}
                <div class="flex items-center h-[42px] " x-ref="dropdown" @click="toggleCheckboxEvent($event, '{{ target }}', '{{ filter_key }}')" role="none">
                    <input type="checkbox" id="checkbox_{{ target }}" name="type[]" value="{{ target }}" class="hidden" @change="toggleOption($event.target.value, $event.target.checked, '{{ filter_key }}') " aria-labelledby="label_{{ target }}">
                    <label for="checkbox_{{ target }}" class="custom-checkbox inline-block mr-2 cursor-pointer" role="menuitemcheckbox"></label>
                    {% if filter_key == "framework" %}
                        <img src="/images/icons/ssgs/{{ target }}.svg" width="16" height="16" alt="{{ target.ssg_name }}" class="mr-[4px] inline-block cursor-pointer" />
                    {% endif %}
                    <span class="cursor-pointer">{{ target | capitalize | strip }}</span>
                </div>
            {% endfor %}
        </div>
    </div>
    {% endfor %}
        
        <!-- Clear filters button -->
        <button x-show="selectedOptions.length > 0" @click="removeAllOptions()" class="inline-block text-cc font-bold text-right py-2 px-3 transition hover:bg-[#F0F5FF] hover:rounded-lg" aria-label="Clear all filters">Clear filters</button>
    </div>
    <!-- Selected Options -->
    <div class="mt-4 gap-x-6 gap-y-1 flex-wrap hidden md:flex" x-show="selectedOptions.length > 0 && !isMobile" x-init="$watch('selectedOptions.length', () => { if(window.innerWidth >= 768) { $el.classList.toggle('hidden', !selectedOptions.length); } })">
        <template x-for="(option, index) in selectedOptions" :key="index">
            <span class="border-2 border-comet rounded-[24px] relative flex items-center justify-between gap-x-[14px] py-3 px-[22px] leading-none">
                <span class="capitalize font-medium m-0 text-carbon" x-text="option"></span>
                <button @click="removeOption(option, index)" class="m-0" aria-label="Remove filter {{ option }}" >
                    <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M1 1L11 11M11 1L1 11" stroke="#393939" stroke-width="2"/>
                    </svg>
                </button>
            </span>
        </template>
    </div>
</div>

<script>
    function filterComponent() {
        // takes array of list elements and filters and modifies the display depending on the filters
        const updateDisplay = (templateList, filters) => {
            const anyFiltersSelected = Object.values(filters).some(filterValues => filterValues.length > 0);
            const listWrapper = document.getElementById('list-wrapper');
            const noResults = document.getElementById('no-results');
            let isResultAvailable = false;
    
            // loop through each template and check if it the item in the filter matches the item in the data attribute
            templateList.forEach(template => {
                const isMatched = !anyFiltersSelected || Object.entries(filters).every(([filterKey, filterValues]) =>
                    filterValues.length === 0 || filterValues.some(value =>
                        template.getAttribute(`data-${filterKey}`).split(' ').includes(value)
                    )
                );
    
                if (isMatched) {
                    isResultAvailable = true;
                }
    
                template.classList.toggle('hidden', !isMatched);
            });
    
            listWrapper.classList.toggle('hidden', !isResultAvailable);
            noResults.classList.toggle('hidden', isResultAvailable);
        };
    
        return {
            show: false,
            open: false,
            isMobile: window.innerWidth < 768,
            filters: {
                framework: [],
                category: [],
                location: [],
            },
            get selectedOptions() {
                return Object.values(this.filters).flat();
            },
            init() {
                window.addEventListener('resize', () => {
                    this.isMobile = window.innerWidth < 768;
                });
    
            },
            toggleCheckboxEvent(event, option, filterType) {
                event.stopPropagation();
                const checkbox = event.currentTarget.querySelector('input[type="checkbox"]');
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                    this.toggleOption(option, checkbox.checked, filterType);
                }
            },
            closeIfClickedOutside(event, index) {
                if (this.$refs.dropdown && !this.$refs.dropdown.contains(event.target) && this.show === index) {
                    this.show = false;
                }
            },
            getButtonText(filterType, filterName) {
                // updates the button labels depending on the number of filters selected, and if the user is on mobile
                const selectedCount = this.filters[filterType]?.length || 0;
                const pluralizeFilterName = filterType === 'category' ? 'categories' : `${filterName}s`;
    
                if (!selectedCount) {
                    return `Filter by ${filterName}`;
                }
    
                const filterText = this.isMobile
                    ? `Filtered by ${selectedCount} ${pluralizeFilterName}`
                    : `Filter by ${filterName}`;
    
                if (selectedCount === 1 && this.isMobile) {
                    return `Filtered by 1 ${filterName}`;
                }
    
                return filterText;
            },
            toggleDropdown(index) {
                // opens and closes the dropdown menu
                this.open = this.show !== index || !this.open;
                this.show = this.open ? index : false;
            },
            toggleOption(option, isChecked, filterType) {
                const filterArray = this.filters[filterType];
                if (!filterArray) {
                    console.error(`Invalid filter type: ${filterType}`);
                    return;
                }
                option = option.toLowerCase().replace(/ /g, '-');
                if (isChecked && !filterArray.includes(option)) {
                    filterArray.push(option);
                } else if (!isChecked) {
                    const optionIndex = filterArray.indexOf(option);
                    if (optionIndex !== -1) {
                        filterArray.splice(optionIndex, 1);
                    }
                }
                this.filterTemplates();
            },
            updateFilters(option, isAdd = true) {
                // updates the filters object - adds or removes the option from the filters object
                Object.entries(this.filters).forEach(([filterType, filterArray]) => {
                    const optionIndex = filterArray.indexOf(option);
    
                    if (isAdd && optionIndex === -1) {
                        filterArray.push(option);
                    } else if (!isAdd && optionIndex !== -1) {
                        filterArray.splice(optionIndex, 1);
                    }
                });
            },
            removeOption(option) {
                const selector = `input[type="checkbox"]`;
                Array.from(document.querySelectorAll(selector)).forEach(input => {
                    const inputValue = input.value.toLowerCase().replace(/ /g, '-');
                    const optionValue = option.toLowerCase().replace(/ /g, '-');
                    if (inputValue === optionValue) {
                        input.checked = false;
                    }
                });
                this.updateFilters(option, false);
                this.filterTemplates();
            },
            removeAllOptions() {
                const selector = 'input[type="checkbox"]';
                Array.from(document.querySelectorAll(selector)).forEach(input => {
                    input.checked = false;
                });
                this.filters = { framework: [], category: [], location: [] };
                this.filterTemplates();
            },
            filterTemplates() {
                // stores all list items in an array and passes it to the updateDisplay function
                const templateList = Array.from(document.querySelectorAll('#list-item'));
                updateDisplay(templateList, this.filters);
            }
        };
    }
    
</script>