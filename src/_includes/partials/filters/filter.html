<!-- custom checkbox styling -->
<style>
    .custom-checkbox {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 16px;
        height: 16px;
        border: 2px solid #034AD8;
        border-radius: 4px;
        position: relative;
        cursor: pointer;
    }
    
    input[type="checkbox"]:checked + .custom-checkbox {
        background-color: #034AD8;
        border-color: #034AD8;
    }
    
    input[type="checkbox"]:checked + .custom-checkbox::after {
        content: '\2713';
        position: absolute;
        color: white;
        font-size: 16px;
    }


</style>

<div x-data="filterComponent()" x-init="init(); initialisePagefind();" class="mb-8 relative">
    <!-- Dropdowns -->
    <div class="flex flex-col md:flex-row gap-4">
        {% for filter in filter_type %}
            <div class="relative inline-block w-full md:w-auto">
                <!-- Button -->
                <button
                  @click.prevent="toggleDropdown('{{ forloop.index }}')" 
                  class="z-10 border-2 border-stone-300/20 rounded-lg px-4 py-3 bg-white w-full md:w-[200px] flex justify-between items-center relative"
                  :class="{
                      'bg-[#F0F5FF]': open && show === '{{ forloop.index }}',
                      'bg-white border-comet/50': !open && isMobile && filters['{{filter}}']?.length > 0,
                      'border-stone-300/20': !open && (!isMobile || filters['{{filter}}']?.length === 0)
                  }"
                  data-index="{{ forloop.index }}"
                  aria-haspopup="true" 
                  :aria-expanded="open && show === '{{ forloop.index }}'"
                  aria-label="Show filters for {{ filter }}"
                  tabindex="0"
                >
                    <span class="inline-block" x-text="generateFilterButtonLabelBasedOnSelectionAndDevice('{{ filter }}', '{{ filter }}')"></span>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="stroke-current inline-block w-3 h-3 text-black transform transition duration-150" :class="{ 'rotate-90': show === '{{ forloop.index }}' }">
                        <path fill-rule="evenodd" d="M16.28 11.47a.75.75 0 010 1.06l-7.5 7.5a.75.75 0 01-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 011.06-1.06l7.5 7.5z" clip-rule="evenodd"/>
                    </svg>
                    <span class="absolute top-0 right-0 w-2 h-2 bg-cc rounded-full" x-show="isMobile && filters['{{ filter }}']?.length > 0" style="transform: translate(50%, -50%);"></span>
                </button>

                <!-- Dropdown -->
    
                <div 
                  x-show.transition="show === '{{ forloop.index }}'" 
                  @click.away="if(show === '{{ forloop.index }}') show = false" 
                  @keydown.escape="if(show === '{{ forloop.index }}') show = false" role="menu"  
                  class="absolute top-full z-20 mt-2 w-full md:w-[200px] shadow-menu rounded-lg px-4 py-4 gap-y-4 whitespace-nowrap bg-white"
                >
                    {% assign filter_key = filter %}
                    {% assign item_collection = collection %}
                    {% assign filter_targets = "" | split: "," %}
        
                    {% if filter_key == "framework" or filter_key == "category" or filter_key == "location" %}
                    {% assign data_keys = "ssg_frameworks,categories,locations" | split: "," %}
                    {% assign key_map = "framework,category,location" | split: "," %}
                    {% assign key_index = -1 %}
                    
                    {% for key in key_map %}
                        {% if key == filter_key %}
                            {% assign key_index = forloop.index0 %}
                        {% endif %}
                    {% endfor %}
                    
                    {% if key_index != -1 %}
                        {% assign target_key = data_keys[key_index] %}
                    {% endif %}
            
                    {% for item in item_collection %}
                        {% assign targets = item.data[target_key] %}
            
                        {% for target in targets %}
                            {% assign trimmed_target = target | strip %}
                            {% if trimmed_target != empty and trimmed_target != null and trimmed_target != "" %}
                                {% if filter_key == "location" %}
                                    {% assign trimmed_target = trimmed_target | capitalize %}
                                {% endif %}
                                {% unless filter_targets contains trimmed_target %}
                                    {% assign filter_targets = filter_targets | push: trimmed_target %}
                                {% endunless %}
                            {% endif %}
                        {% endfor %}
                    {% endfor %}
                {% endif %}
    
                {% assign filter_targets = filter_targets | sort %}

                    {% for target in filter_targets %}
                        <div 
                          class="flex items-center h-[42px]" 
                          x-ref="dropdown" 
                          @click="toggleCheckboxEvent($event, '{{ target }}', '{{ filter_key }}')" 
                          role="none" @keydown.space.prevent="toggleCheckboxEvent($event, '{{ target }}', '{{ filter_key }}')" 
                          @keydown.enter.prevent="toggleCheckboxEvent($event, '{{ target }}', '{{ filter_key }}')" 
                          tabindex="0"
                        >
                            <input 
                              type="checkbox" 
                              id="checkbox_{{ target }}" 
                              name="type[]" 
                              value="{{ target }}" 
                              class="hidden" 
                              @change="addOrRemoveFilterOptionAndUpdateRenderedItems($event.target.value, $event.target.checked, '{{ filter_key }}')" 
                              aria-labelledby="label_{{ target }}" 
                            >
                            <label for="checkbox_{{ target }}" class="custom-checkbox inline-block mr-2 cursor-pointer" role="menuitemcheckbox"></label>
                            {% if filter_key == "framework" %}
                                <img src="/images/icons/ssgs/{{ target }}.svg" width="16" height="16" alt="{{ target.ssg_name }}" class="mr-[4px] inline-block cursor-pointer"/>
                            {% endif %}
                            <span class="cursor-pointer">{{ target | capitalize | strip }}</span>
                        </div>
                    {% endfor %}
                </div>
            </div>
        {% endfor %}
        
        <!-- Clear filters button -->
        <button 
          x-show="selectedOptions.length > 0" 
          @click="removeAllOptionsFromFilter()" 
          class="inline-block text-cc font-bold text-right py-2 px-3 transition hover:bg-[#F0F5FF] hover:rounded-lg" 
          aria-label="Clear all filters" 
          tabindex="0"
        >
            Clear filters
        </button>
    </div>
     <!-- Selected Options -->
     <div 
     class="mt-4 gap-x-6 gap-y-1 flex-wrap hidden md:flex" 
     x-show="selectedOptions.length > 0 && !isMobile" 
     x-init="$watch('selectedOptions.length', () => { if(window.innerWidth >= 768) { $el.classList.toggle('hidden', !selectedOptions.length); } })"
     >
        <template x-for="(option, index) in selectedOptions" :key="index">
            <span class="border-2 border-comet rounded-[24px] relative flex items-center justify-between gap-x-[14px] py-3 px-[22px] leading-none">
                <span class="capitalize font-medium m-0 text-carbon" x-text="option"></span>
                <button @click="removeOptionFromFilter(option, index)" class="m-0" aria-label="Remove filter {{ option }}" >
                    <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M1 1L11 11M11 1L1 11" stroke="#393939" stroke-width="2"/>
                    </svg>
                </button>
            </span>
        </template>
    </div>
</div>


<script>
    function filterComponent() {
        return {
            show: false,
            open: false,
            usesPagefind: false,
            loading: false,
            pagefind: "",
            isMobile: window.innerWidth < 768,
            filters: {
                framework: [],
                category: [],
                location: [],
            },
    
            toggleLoadingState(isLoading) {
                this.loading = isLoading;
            },
    
            initialisePagefind() {
                (async () => {
                    try {
                        this.pagefind = this.pagefind
                        ? this.pagefind
                        : await import("/_pagefind/pagefind.js");
                    } catch (e) {
                        this.error = 'Failed to load search, please refresh'
                    }
                    })();
            },
    
            get selectedOptions() {
                return Object.values(this.filters).flat();
            },
            init() {
                this.setUsesPagefind();
                window.addEventListener('resize', () => {
                    this.isMobile = window.innerWidth < 768;
                });
    
            },
            setUsesPagefind() {
                // Set usesPagefind to true if an element with id 'page-find' exists, otherwise set it to false.
                this.usesPagefind = document.getElementById('pagefind-filtering') ? true : false;
            },
    
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },
    
            toggleCheckboxEvent(event, option, filterType) {
                event.stopPropagation();
                const checkbox = event.currentTarget.querySelector('input[type="checkbox"]');
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                    this.addOrRemoveFilterOptionAndUpdateRenderedItems(option, checkbox.checked, filterType);
                }
            },
    
            generateFilterButtonLabelBasedOnSelectionAndDevice(filterType, filterName) {
                // updates the button labels depending on the number of filters selected, and if the user is on mobile
                const selectedCount = this.filters[filterType]?.length || 0;
                const pluralizeFilterName = filterType === 'category' ? 'categories' : `${filterName}s`;
    
                if (!selectedCount) {
                    return `Filter by ${filterName}`;
                }
    
                const filterText = this.isMobile
                    ? `Filtered by ${selectedCount} ${pluralizeFilterName}`
                    : `Filter by ${filterName}`;
    
                if (selectedCount === 1 && this.isMobile) {
                    return `Filtered by 1 ${filterName}`;
                }
    
                return filterText;
            },
            toggleDropdown(index) {
                // opens and closes the dropdown menu
                this.open = this.show !== index || !this.open;
                this.show = this.open ? index : false;
            },
            addOrRemoveFilterOptionAndUpdateRenderedItems(option, isChecked, filterType) {
                const filterArray = this.filters[filterType];
                if (!filterArray) {
                    console.error(`Invalid filter type: ${filterType}`);
                    return;
                }
                option = option.toLowerCase().replace(/ /g, '-');
                if (isChecked && !filterArray.includes(option)) {
                    filterArray.push(option);
    
                } else if (!isChecked) {
                    const optionIndex = filterArray.indexOf(option);
                    if (optionIndex !== -1) {
                        filterArray.splice(optionIndex, 1);
                    }
                }
                this.updateShownPostsBasedOnPagefindUsage();
            },
            addOrRemoveOptionFromAllFilterTypes(option, isAdd = true) {
                // updates the filters object - adds or removes the option from the filters object
                Object.entries(this.filters).forEach(([filterType, filterArray]) => {
                    const optionIndex = filterArray.indexOf(option);
    
                    if (isAdd && optionIndex === -1) {
                        filterArray.push(option);
                    } else if (!isAdd && optionIndex !== -1) {
                        filterArray.splice(optionIndex, 1);
                    }
                });
            },
            removeOptionFromFilter(option) {
                const selector = `input[type="checkbox"]`;
                Array.from(document.querySelectorAll(selector)).forEach(input => {
                    const inputValue = input.value.toLowerCase().replace(/ /g, '-');
                    const optionValue = option.toLowerCase().replace(/ /g, '-');
                    if (inputValue === optionValue) {
                        input.checked = false;
                    }
                });
                this.addOrRemoveOptionFromAllFilterTypes(option, false);
    
                this.updateShownPostsBasedOnPagefindUsage();
            },
            removeAllOptionsFromFilter() {
                const selector = 'input[type="checkbox"]';
                Array.from(document.querySelectorAll(selector)).forEach(input => {
                    input.checked = false;
                });
                if (this.usesPagefind) {
                    this.toggleElementVisibility("no-results", false);
                }
                this.filters = { framework: [], category: [], location: [] };
                
                this.updateShownPostsBasedOnPagefindUsage();
            },
            updateShownPostsBasedOnPagefindUsage() {
         
                // stores all list items in an array and passes it to the updateShownPostsWithoutPagefind function
                if (this.usesPagefind){
                    this.debounce(this.updateShownPostsWithPagefind(this.filters), 50);
                }else{
                    const templateList = Array.from(document.querySelectorAll('#list-item'));
                     this.updateShownPostsWithoutPagefind(templateList, this.filters);
                }
             
            },
    
            updateShownPostsWithoutPagefind(templateList, filters) {
                const anyFiltersSelected = this.areAnyFiltersSelected(filters);
                const listWrapper = document.getElementById('list-wrapper');
                const noResults = document.getElementById('no-results');
                let isResultAvailable = false;
        
                // loop through each template and check if it the item in the filter matches the item in the data attribute
                templateList.forEach(template => {
                    const isMatched = !anyFiltersSelected || Object.entries(filters).every(([filterKey, filterValues]) =>
                        filterValues.length === 0 || filterValues.some(value =>
                            template.getAttribute(`data-${filterKey}`).split(' ').includes(value)
                        )
                    );
        
                    if (isMatched) {
                        isResultAvailable = true;
                    }
        
                    template.classList.toggle('hidden', !isMatched);
                });
        
                listWrapper.classList.toggle('hidden', !isResultAvailable);
                noResults.classList.toggle('hidden', isResultAvailable);
            },
    
            
    
    
            async getSearchResults(filters) {
                return await this.pagefind.search(null, { 
                    filters: {
                        framework: {
                            any: filters.framework
                        },
                        category: {
                            any: filters.category
                        },
                    },
                    sort: {
                        date: "desc"
                    }
                });
            },
            
             manageLoadingState(isLoading, loadingContainer, visiblePostCount) {
                if (isLoading) {
                    this.clearResultsContainer();
                    // Show skeleton posts
                    for(let i = 0; i < visiblePostCount; i++) {
                        const skeletonPost = this.createSkeletonPost();
                        loadingContainer.appendChild(skeletonPost);
                    }
                    //this.toggleElementVisibility("loading-container", true);
                } else {
                    // Remove skeleton posts
                    while(loadingContainer.firstChild){
                        loadingContainer.removeChild(loadingContainer.firstChild);
                    }
                    //this.toggleElementVisibility("loading-container", false);
                    this.toggleLoadingState(false);
                }
            },
            
            async getPagefindResults(results) {
                const resultsData = await Promise.all(results.map(result => result.data()));
                this.createAndAppendGridForPosts(resultsData);
            },
            
            async updateShownPostsWithPagefind(filters) {
                try {
                    const areFiltersActive = this.areAnyFiltersSelected(filters);
                    const noResults = document.getElementById('no-results');
                    const loadingContainer = document.getElementById('loading-container');
            
                    if (!areFiltersActive) {
                        this.clearResultsContainer();
                        this.toggleElementVisibility("post-container", true);
                        this.toggleElementVisibility("pagination-container", true);
                        return;
                    }
            
                    const searchResults = await this.getSearchResults(filters);
            
                    this.toggleElementVisibility("no-results", searchResults.results.length === 0);
                    this.toggleElementVisibility("post-container", false);
                    this.toggleElementVisibility("pagination-container", false);
                    
                    const estimatedPostHeight = 150; 
                    let visiblePostCount = this.calculateVisiblePosts(estimatedPostHeight);
                    
                    visiblePostCount = Math.min(visiblePostCount, searchResults.results.length);
                    visiblePostCount = Math.max(visiblePostCount, 1);
            
                    this.manageLoadingState(true, loadingContainer, visiblePostCount);
            
                    await this.getPagefindResults(searchResults.results);
            
                    this.manageLoadingState(false, loadingContainer);
                } catch (error) {
                    console.error('An error occurred during fetching and displaying the results:', error);
                }
            },
            
    
            calculateVisiblePosts(estimatedPostHeight) {
                const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
                return Math.floor(viewportHeight / estimatedPostHeight);
            },
            
            
            
            createSkeletonElement(elementType, classNames) {
                const element = document.createElement(elementType);
                element.classList.add(...classNames);
                return element;
            },
            
            createSkeletonPost() {
                const fragment = document.createDocumentFragment();
            
                const skeletonPost = this.createSkeletonElement("div", ["skeleton-post", "animate-pulse", "mb-4", "flex", "flex-col", "gap-y-4"]);
                fragment.appendChild(skeletonPost);
            
                const skeletonPostImage = this.createSkeletonElement("div", ["skeleton-post-Image", "transition", "rounded-lg", "h-64", "w-full", "animate-pulse", "bg-gray-400"]);
                skeletonPost.appendChild(skeletonPostImage);
            
                const skeletonPostTags = this.createSkeletonElement("div", ["skeleton-post-Tags", "p-4", "w-1/2", "bg-gray-400", "animate-pulse", "rounded-lg"]);
                skeletonPost.appendChild(skeletonPostTags);
            
                const skeletonPostTitle = this.createSkeletonElement("div", ["skeleton-post-Title", "p-6", "w-full", "bg-gray-400", "animate-pulse", "rounded-lg"]);
                skeletonPost.appendChild(skeletonPostTitle);
            
                const skeletonPostAuthor = this.createSkeletonElement("div", ["skeleton-post-Author", "p-2", "w-1/2", "bg-gray-400", "rounded-lg"]);
                skeletonPost.appendChild(skeletonPostAuthor);
            
                
                return fragment;
            },

             
            
              
              
              
    
            areAnyFiltersSelected(filters){
                return Object.values(filters).some(filterArray => filterArray.length > 0);
            },
    
            toggleElementVisibility(elementId, isVisible){
                document.getElementById(elementId).classList.toggle("hidden", !isVisible);
            },
        
            clearResultsContainer(){
                const resultsContainer = document.getElementById("results");
                while (resultsContainer.firstChild) {
                    resultsContainer.removeChild(resultsContainer.firstChild);
                }
            },
    
    
            createAndAppendGridForPosts(results) {
    
                const container = document.createElement("div");
                container.classList.add("grid", "grid-cols-1", "md:grid-cols-2", "xl:grid-cols-3", "gap-x-5", "gap-y-12");
            
                // Create a new DocumentFragment
                const fragment = document.createDocumentFragment();
            
                results.forEach(post => {
                    const postContainer = this.createPostContainer(post);
                    if (postContainer) {
                        // Appends postContainer to the fragment instead of the actual container
                        fragment.appendChild(postContainer);
                    }
                });
            
                // Appends the DocumentFragment to the container
                container.appendChild(fragment);
    
                const gridContainer = document.getElementById("results");
            
                // Clear the current grid before appending new one
                while (gridContainer.firstChild) {
                    gridContainer.removeChild(gridContainer.firstChild);
                }
            
                gridContainer.appendChild(container);
    
    
            },
            
            createPostContainer(post) {
                const tagsArray = post.meta.blog_tags.split(',');
                
                
    
                const postContainer = document.createElement("div");
                
                postContainer.appendChild(this.createImageElement(post));
                postContainer.appendChild(this.createTagsContainer(post));
                postContainer.appendChild(this.createTitleElement(post));
                postContainer.appendChild(this.createAuthorDateElement(post));
    
                return postContainer;
            },
            
            createImageElement(post) {
                const imageLink = document.createElement("a");
                imageLink.href = post.url;
                imageLink.classList.add("group");
                
                const image = document.createElement("img");
                image.src = `${post.meta.blog_image}?auto=compress&auto=format&w=584&dpr=2&crop=faces&fit=crop&height=316`;
                image.alt = post.meta.image_alt;
                image.classList.add("transition", "rounded-lg", "group-hover:opacity-80", "group-hover:scale-105", "h-[250px]", "object-center", "object-cover", "w-full");
    
                imageLink.appendChild(image);
    
                return imageLink;
            },
            
            createTagsContainer(post) {
                const tagsContainer = document.createElement("div");
                tagsContainer.classList.add("text-gray-400", "mt-2");
        
                const tagsArray = post.meta.blog_tags.split(',');
        
                tagsArray.forEach((tag, index) => {
                    if (tag === "posts") return;
        
                    const tagLink = document.createElement("a");
                    tagLink.href = `/blog/tags/${encodeURIComponent(tag.trim()).toLowerCase()}/`;
                    tagLink.textContent = tag.trim();
                    tagLink.classList.add("text-cc", "uppercase", "hover:text-cc_hover", "hover:underline", "transition");
                    tagsContainer.appendChild(tagLink);
        
                    if (index < tagsArray.length - 1) {
                        const separator = document.createElement("span");
                        separator.classList.add("first:hidden");
                        separator.innerHTML = " &middot; ";
                        tagsContainer.appendChild(separator);
                    }
                });
        
                return tagsContainer;
            },
            
            createTitleElement(post) {
                const title = document.createElement("h3");
                title.classList.add("font-bold", "text-2xl", "md:text-3xl", "mt-1", "text-carbon");
    
                const titleLink = document.createElement("a");
                titleLink.href = post.url;
                titleLink.textContent = post.meta.title;
                titleLink.classList.add("hover:underline");
    
                title.appendChild(titleLink);
    
                return title;
            },
            
            createAuthorDateElement(post) {
                const authorDateContainer = document.createElement("p");
                authorDateContainer.classList.add("mt-3", "text-gray-900");
                authorDateContainer.textContent = `${post.meta.blog_author} · ${new Date(post.meta.blog_date).toLocaleDateString("en-US", { day: 'numeric', month: 'short', year: 'numeric' })}`;
    
                return authorDateContainer;
            },
        };
    }
</script>

